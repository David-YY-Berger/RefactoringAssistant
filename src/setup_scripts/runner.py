import ctypesimport shutilimport osimport subprocessimport syslatest_version_txt_path = r"Y:\QA\Automation\RefactoringAssistant\version_available.txt"latest_version_dir_to_exe_path = r"Y:\QA\Automation\RefactoringAssistant\newVersion"cur_dir_of_this_exe = os.path.abspath(os.path.dirname(sys.argv[0]))# cur_dir_of_this_exe = r'C:\Users\davidbe\AppData\Local\RefactoringAssistantHidden'cur_version_txt_file_path = os.path.join(cur_dir_of_this_exe, 'cur_version.txt')dir_of_cur_version_exe_path = os.path.join(cur_dir_of_this_exe, 'newVersion')cur_version_exe_file_path = os.path.join(dir_of_cur_version_exe_path, 'main-RefactoringAssistant.exe')def main():    # if exists:    if os.path.isfile(cur_version_txt_file_path) and os.path.isfile(cur_version_exe_file_path):        # if updated:        if read_file_content_as_str(cur_version_txt_file_path) == read_file_content_as_str(latest_version_txt_path):            safe_run_exe(cur_version_exe_file_path)        else:            copy_files_and_run()    #         keep this unnecessary if & else breakdown for now    else:        copy_files_and_run()    input("Press any key to close the program :)")def copy_files_and_run():    # these are not extraneous!! they catch certain cases    if os.path.isfile(cur_version_txt_file_path):        os.remove(cur_version_txt_file_path)    if os.path.isdir(dir_of_cur_version_exe_path):        shutil.rmtree(dir_of_cur_version_exe_path)    print('Updating to the latest version..this might take 2 min')    shutil.copyfile(latest_version_txt_path, cur_version_txt_file_path)    hide_path(cur_version_txt_file_path)    copy_files(latest_version_dir_to_exe_path, dir_of_cur_version_exe_path)    hide_path(dir_of_cur_version_exe_path)    safe_run_exe(cur_version_exe_file_path)def safe_run_exe(exe_path):    print('Opening the application.. please wait')    try:        # Run the executable        subprocess.run([exe_path])    except subprocess.CalledProcessError as e:        print(f"Error running the executable: {e}")    except FileNotFoundError:        print(f"Executable not found at {exe_path}")    except Exception as e:        print(f"An unexpected error occurred: {e}")def read_file_content_as_str(path, encoding='utf-8'):    try:        with open(path, 'r', encoding=encoding) as file:            file_content = file.read()            return file_content    except FileNotFoundError:        print(f"The file at {path} does not exist.")    except Exception as e:        print(f"An error occurred: {e}")def hide_path(path):    attrs = ctypes.windll.kernel32.GetFileAttributesW(path)    ctypes.windll.kernel32.SetFileAttributesW(path, attrs | 2)def copy_files(src_path_dir, dest_path_dir):    if not os.path.exists(dest_path_dir):        os.makedirs(dest_path_dir)    for root, dirs, files in os.walk(src_path_dir):        for file in files:            src_file_path = os.path.join(root, file)            dest_file_path = os.path.join(dest_path_dir, os.path.relpath(src_file_path, src_path_dir))            # Ensure the destination directory for the file exists            dest_file_dir = os.path.dirname(dest_file_path)            if not os.path.exists(dest_file_dir):                os.makedirs(dest_file_dir)            # Copy the file            shutil.copy2(src_file_path, dest_file_path)if __name__ == "__main__":    main()